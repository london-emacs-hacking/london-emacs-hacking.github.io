<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-03-02 Mon 18:42 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Dojo | Emacs London</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" type="text/css" href="assets/css/style.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<center><a class="logo-href" href="/index.html"><img src="./assets/images/emacs-london-logo.png" alt="emacs-london image" class="logo"></a></center>
</div>
<div id="content">

<div id="outline-container-org3914def" class="outline-2">
<h2 id="org3914def">Emacs Lisp dojo</h2>
<div class="outline-text-2" id="text-org3914def">
<p>
A dojo is a meetup format that involves coding on projects or exercises, usually
in groups, for the purpose of practice and learning. There are many dojo meetups
that run for different audiences. Attendees may be familiar with the <a href="http://www.londonclojurians.org/code-dojo/">London
Clojure Dojo</a>.
</p>

<p>
Our format is:
</p>

<ol class="org-ol">
<li>Everyone suggests ideas for a project.</li>
<li>Break into small groups, each focusing on a project (or on the exercises below).</li>
<li>Work for 90 minutes.</li>
<li>Present some learnings, or maybe head straight to a pub.</li>
</ol>
</div>
</div>

<div id="outline-container-orgcd4c7a9" class="outline-2">
<h2 id="orgcd4c7a9"><a href="https://raw.githubusercontent.com/london-emacs-hacking/london-emacs-hacking.github.io/master/dojo.org">Interactive exercises</a></h2>
<div class="outline-text-2" id="text-orgcd4c7a9">
<p>
These are some exercises to help learn and explore Emacs and Elisp. The aim is
to fill in the functions labelled <code>__</code>, so that all the <code>Pass:</code> messages show <code>t</code>
instead of <code>nil</code>.
</p>

<p>
They are inspired by the interactive Clojure exercises on <a href="https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;ved=2ahUKEwiTyNypxavnAhXLQEEAHVdVB5gQjBAwAXoECAgQCA&amp;url=http%3A%2F%2Fwww.4clojure.com%2Fproblems&amp;usg=AOvVaw0pa24yxcj-qETh0ze7m_08">4Clojure</a>.
</p>

<p>
Alternatively, you may want to explore the <a href="#orgf59b3c8">open-ended project ideas</a> at the bottom of this page.
</p>
</div>

<div id="outline-container-org82306d2" class="outline-3">
<h3 id="org82306d2">Working with this org-mode file</h3>
<div class="outline-text-3" id="text-org82306d2">
<p>
This web page is written as an org-mode file, which means you can <a href="https://raw.githubusercontent.com/london-emacs-hacking/london-emacs-hacking.github.io/master/dojo.org">get it on
github</a>, open it in Emacs, and execute the code snippets by moving to a code
block and pressing <code>C-c C-c</code>. You can also open and edit the code block in
emacs-lisp mode by pressing <code>C-c '</code>.
</p>
</div>
</div>

<div id="outline-container-org94fae4a" class="outline-3">
<h3 id="org94fae4a">Resources to help</h3>
<div class="outline-text-3" id="text-org94fae4a">
<p>
If you're new to Elisp, the resources below can act as starting points or
references.
</p>

<ul class="org-ul">
<li>Emacs itself: there are some very useful features to help you learn about
the language, available functions, current values of your variables, and
more. These are all accessible via <code>C-h</code>. You can <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Help.html">start reading about them in
the manual</a>.</li>

<li>The <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html">Emacs Lisp reference manual</a> is very comprehensive if you know what you
want to read about. This can also be read within Emacs by using <code>C-h i m Elisp RET</code>.</li>

<li>Steve Yegge wrote <a href="https://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">a brief overview of all the language features</a>. It's quite
old now but is still a nice place to start.</li>

<li><a href="http://ergoemacs.org/emacs/elisp.html">Xah Lee's practical Emacs Lisp guide</a> may be easier to digest than the full
manual, and covers a lot of topics.</li>
</ul>
</div>
</div>

<div id="outline-container-org7ac4e10" class="outline-3">
<h3 id="org7ac4e10">Contributing</h3>
<div class="outline-text-3" id="text-org7ac4e10">
<p>
Changes and new exercises are very welcome! Please <a href="https://github.com/london-emacs-hacking/london-emacs-hacking.github.io">submit PRs on github</a>.
</p>
</div>
</div>

<div id="outline-container-org091c947" class="outline-3">
<h3 id="org091c947">Index</h3>
<div class="outline-text-3" id="text-org091c947">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Title</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#org200ec1d">Strings - uppercase</a></td>
</tr>

<tr>
<td class="org-left"><a href="#orgccdd34b">Penultimate element</a></td>
</tr>

<tr>
<td class="org-left"><a href="#orgad0dec9">Fizzbuzz</a></td>
</tr>

<tr>
<td class="org-left"><a href="#org5795d41">Flatten an arbitrarily nested list</a></td>
</tr>

<tr>
<td class="org-left"><a href="#orgc679152">Count the lines and words in a buffer</a></td>
</tr>

<tr>
<td class="org-left"><a href="#org27f1489">Convert a list into a hash table</a></td>
</tr>

<tr>
<td class="org-left"><a href="#org7b2bb77">Reimplement mapcar</a></td>
</tr>

<tr>
<td class="org-left"><a href="#orgcd51970">Handle errors</a></td>
</tr>

<tr>
<td class="org-left"><a href="#orgf0a47fa">Throw and catch</a></td>
</tr>

<tr>
<td class="org-left"><a href="#org4b0cce2">Use a regex to extract numbers from a buffer</a></td>
</tr>

<tr>
<td class="org-left"><a href="#orgf24b133">Make an HTTP request and parse the JSON response</a></td>
</tr>

<tr>
<td class="org-left"><a href="#org22feba5">Read output from a shell command</a></td>
</tr>

<tr>
<td class="org-left"><a href="#org930c2c0">Parse data from an org buffer</a></td>
</tr>

<tr>
<td class="org-left"><a href="#orgea03bbf">Apply a custom font face to TODO words in a buffer</a></td>
</tr>

<tr>
<td class="org-left"><a href="#org6725689">Anagram finder</a></td>
</tr>

<tr>
<td class="org-left"><a href="#org22ac9e1">Analyse a tic tac toe board</a></td>
</tr>

<tr>
<td class="org-left"><a href="#org5f10b01">Advice: 2 + 2 = 5</a></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org200ec1d" class="outline-3">
<h3 id="org200ec1d">Strings - uppercase</h3>
<div class="outline-text-3" id="text-org200ec1d">
<p>
Transform the given string into uppercase:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ (s))

(let* ((result (__ "helloworld"))
       (pass (string= result "HELLOWORLD")))
  (format "Pass:%S\n%S" pass result))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgccdd34b" class="outline-3">
<h3 id="orgccdd34b">Penultimate element</h3>
<div class="outline-text-3" id="text-orgccdd34b">
<p>
Return the second last element in a list. If there is only one item in the
list, return nil.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ (li) nil)

(let* ((result1 (__ '(1 2 3 4 5)))
       (pass1 (equal result1 4))
       (result2 (__ '("a" "b" "c")))
       (pass2 (equal result2 "b"))
       (result3 (__ '([1 2] [3 4])))
       (pass3 (equal result3 [1 2]))
       (result4 (__ '(1)))
       (pass4 (equal result4 nil)))

  (format "Pass:%S\n%S\n\nPass:%S:\n%S\n\nPass:%S\n%S\n\nPass:%S\n%S"
          pass1 result1 pass2 result2 pass3 result3 pass4 result4))
</pre>
</div>

<p>
(Ported from <a href="http://www.4clojure.com/problem/20">4Clojure #20</a>)
</p>
</div>
</div>

<div id="outline-container-orgad0dec9" class="outline-3">
<h3 id="orgad0dec9">Fizzbuzz</h3>
<div class="outline-text-3" id="text-orgad0dec9">
<p>
Return a list with the results of fizzbuzz for a range of 1-100. This means:
</p>

<ul class="org-ul">
<li>If the number is divisible by 3, the value is "Fizz".</li>
<li>If the number is divisible by 5, the value is "Buzz".</li>
<li>If the number is divisible by 3 and 5, the value is "FizzBuzz".</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ () nil)

(let* ((expected '(1 2 "Fizz" 4 "Buzz" "Fizz" 7 8 "Fizz" "Buzz" 11 "Fizz" 13 14 "FizzBuzz" 16 17
                     "Fizz" 19 "Buzz" "Fizz" 22 23 "Fizz" "Buzz" 26 "Fizz" 28 29 "FizzBuzz" 31 32
                     "Fizz" 34 "Buzz" "Fizz" 37 38 "Fizz" "Buzz" 41 "Fizz" 43 44 "FizzBuzz" 46 47
                     "Fizz" 49 "Buzz" "Fizz" 52 53 "Fizz" "Buzz" 56 "Fizz" 58 59 "FizzBuzz" 61 62
                     "Fizz" 64 "Buzz" "Fizz" 67 68 "Fizz" "Buzz" 71 "Fizz" 73 74 "FizzBuzz" 76 77
                     "Fizz" 79 "Buzz" "Fizz" 82 83 "Fizz" "Buzz" 86 "Fizz" 88 89 "FizzBuzz" 91 92
                     "Fizz" 94 "Buzz" "Fizz" 97 98 "Fizz" "Buzz" ))
       (result (__))
       (pass (equal result expected)))
  (format "Pass:%S\n%S" pass result))
</pre>
</div>
</div>
</div>

<div id="outline-container-org5795d41" class="outline-3">
<h3 id="org5795d41">Flatten an arbitrarily nested list</h3>
<div class="outline-text-3" id="text-org5795d41">
<p>
Pull out all the nested elements into a single list:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ (a &amp;rest b))

(let* ((result1 (__ '(1 2 3)))
       (pass1 (equal result1 '(1 2 3)))
       (result2 (__ '(1 2 (3 4) (5 (6 (7))))))
       (pass2 (equal result2 '(1 2 3 4 5 6 7)))
       (result3 (__ '("a" "b") '(c nil d) '(1 (2 3 (4 5)))))
       (pass3 (equal result3 '("a" "b" c d 1 2 3 4 5))))
  (format "Pass:%S\n%S\nPass:%S\n%S\nPass:%S\n%S" pass1 result1 pass2 result2 pass3 result3))
</pre>
</div>
</div>
</div>

<div id="outline-container-org27f1489" class="outline-3">
<h3 id="org27f1489">Convert a list into a hash table</h3>
<div class="outline-text-3" id="text-org27f1489">
<p>
Given a list of cons cells (eg. <code>'((a . 123) (b . 456))</code>) create a hash table
where the car is the key and the cdr is the value.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ (s))

(let* ((result (__ '((a . 123) (b . 456) (c . "789"))))
       (pass (equal result #s(hash-table size 3 data (a 123 b 456 c "789")))))
  (format "Pass:%S\n%S" pass result))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc679152" class="outline-3">
<h3 id="orgc679152">Count the lines and words in a buffer</h3>
<div class="outline-text-3" id="text-orgc679152">
<p>
Depending on whether the second argument is the symbol <code>'lines</code> or <code>'words</code>, you
should return a number that represents the appropriate count. Bonus points if
you don't use any of the default line/word count functions.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ (buffer arg) 0)

(with-temp-buffer
  (insert "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore
et dolore magna aliqua. Maecenas sed enim ut sem viverra aliquet. In mollis nunc sed id semper risus
in. In hac habitasse platea dictumst quisque sagittis. Facilisis magna etiam tempor orci eu. Tempus
egestas sed sed risus pretium quam vulputate dignissim. Eros donec ac odio tempor orci dapibus
ultrices. Nam libero justo laoreet sit. Quis imperdiet massa tincidunt nunc pulvinar. Quis imperdiet
massa tincidunt nunc pulvinar sapien et. Consequat semper viverra nam libero justo. Volutpat
maecenas volutpat blandit aliquam etiam erat. Viverra tellus in hac habitasse platea. Condimentum
vitae sapien pellentesque habitant. Eleifend mi in nulla posuere sollicitudin aliquam ultrices
sagittis orci. Vitae elementum curabitur vitae nunc sed velit dignissim sodales. Vel risus commodo
viverra maecenas. Tellus molestie nunc non blandit massa enim. Sed ullamcorper morbi tincidunt
ornare massa eget egestas purus viverra. Donec ultrices tincidunt arcu non sodales neque sodales ut.

Eu tincidunt tortor aliquam nulla. Amet justo donec enim diam vulputate. Tristique senectus et netus
et malesuada fames. Tellus elementum sagittis vitae et. Blandit cursus risus at ultrices mi
tempus. Sit amet purus gravida quis blandit turpis. Metus vulputate eu scelerisque felis
imperdiet. Nulla porttitor massa id neque. Dictum fusce ut placerat orci nulla
pellentesque. Pulvinar mattis nunc sed blandit libero volutpat sed. Amet venenatis urna cursus eget
nunc scelerisque viverra mauris in. Morbi quis commodo odio aenean. Pellentesque massa placerat duis
ultricies. Tristique sollicitudin nibh sit amet. Gravida cum sociis natoque penatibus et magnis dis
parturient. Ut ornare lectus sit amet est. Enim nunc faucibus a pellentesque sit amet
porttitor. Nisl suscipit adipiscing bibendum est ultricies integer quis. Risus pretium quam
vulputate dignissim suspendisse in.")

  (let* ((result1 (__ (current-buffer) 'lines))
         (pass1 (= result1 21))
         (result2 (__ (current-buffer) 'words))
         (pass2 (= result2 283)))
    (format "Pass:%S\n%S\nPass:%S\n%S" pass1 result1 pass2 result2)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7b2bb77" class="outline-3">
<h3 id="org7b2bb77">Reimplement mapcar</h3>
<div class="outline-text-3" id="text-org7b2bb77">
<p>
<a href="https://en.wikipedia.org/wiki/Map_(higher-order_function)">map</a> is a function that applies a given function to each element of a given
list. In Emacs there are a <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Mapping-Functions.html">few variants of map functions</a>. Write a function that
mimics the behaviour of <code>mapcar</code>. It accepts two argument: the function to apply,
and the list of args to operate on.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ (fn args))

(let* ((result1 (__ 'upcase '("apple" "banana" "pear")))
       (pass1 (equal result1 '("APPLE" "BANANA" "PEAR")))
       (result2 (__ (lambda (arg) (= 0 (mod arg 2))) '(0 1 2 3 4 5 6 7 8 9)))
       (pass2 (equal result2 '(t nil t nil t nil t nil t nil))))
  (format "Pass:%S\n%S\nPass:%S\n%S" pass1 result1 pass2 result2))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcd51970" class="outline-3">
<h3 id="orgcd51970">Handle errors</h3>
<div class="outline-text-3" id="text-orgcd51970">
<p>
You can find some information on error handling <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Handling-Errors.html#Handling-Errors">in the manual</a>, along with a <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Standard-Errors.html#Standard-Errors">list
of standard errors</a>. Write a function that catches some particular errors and
returns their value. Hint: you probably want to use <code>(condition-case)</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ (fn))

(let* ((result1 (__ (lambda () (error "Something went wrong: %s" 'mysymbol))))
       (pass1 (equal result1 "Something went wrong: mysymbol"))
       (result2 (__ (lambda () (/ 5 0))))
       (pass2 (equal result2 "Division by zero"))
       (result3 (__ (lambda () (throw 'catchmeplease "myvalue"))))
       (pass3 (equal result3 '(uncaught . "myvalue"))))
  (format "Pass:%S\n%S\nPass:%S\n%S\nPass:%S\n%S" pass1 result1 pass2 result2 pass3 result3))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf0a47fa" class="outline-3">
<h3 id="orgf0a47fa">Throw and catch</h3>
<div class="outline-text-3" id="text-orgf0a47fa">
<p>
<code>catch</code> and <code>throw</code> are used for control flow, but not necessarily errors. Write a
function that executes the given <code>fn</code>, catches the <code>throw</code> from our lambda, and
returns the expected value:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ (fn))

(let* ((result (__ (lambda () (throw 'label "message"))))
       (pass (equal result '(label . "message"))))
  (format "Pass:%S\n%S" pass result))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4b0cce2" class="outline-3">
<h3 id="org4b0cce2">Use a regex to extract numbers from a buffer</h3>
<div class="outline-text-3" id="text-org4b0cce2">
<p>
The numbers should be extracted into a list. Note: <code>\d</code> is not supported.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ (buffer))

(let* ((result1 (with-temp-buffer
                  (insert "There are 2 numbers in this buffer. The second one is 123")
                  (__ (current-buffer))))
       (pass1 (equal result1 '(2 123)))
       (result2 (with-temp-buffer
                  (insert "There are no numbers in this buffer")
                  (__ (current-buffer))))
       (pass2 (equal result2 nil)))
  (format "Pass:%S\n%S\nPass:%S\n%S" pass1 result1 pass2 result2))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf24b133" class="outline-3">
<h3 id="orgf24b133">Make an HTTP request and parse the JSON response</h3>
<div class="outline-text-3" id="text-orgf24b133">
<p>
Make an HTTP request to httpbin.org and convert the "args" from the JSON
response into an alist.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ (url) nil)

(let* ((result (__ "https://httpbin.org/get?one=two&amp;three=four"))
       (pass (equal result '((one . "two") (three . "four")))))
  (format "Pass:%S\n%S" pass result))
</pre>
</div>
</div>
</div>

<div id="outline-container-org22feba5" class="outline-3">
<h3 id="org22feba5">Read output from a shell command</h3>
<div class="outline-text-3" id="text-org22feba5">
<p>
There are various ways to call external processes in Emacs. Eval the given
argument in a shell and return the result.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ (shellcommand))

(let* ((result (__ "echo 'always eval user input'"))
       (pass (equal result "always eval user input")))
  (format "Pass:%S\n%S" pass result))
</pre>
</div>
</div>
</div>

<div id="outline-container-org930c2c0" class="outline-3">
<h3 id="org930c2c0">Parse data from an org buffer</h3>
<div class="outline-text-3" id="text-org930c2c0">
<p>
Given the string below, convert it to an org-mode buffer, parse out the headline
and tags, and return a list where each item looks like <code>("HEADLINE" . '("TAG1" "TAG2"))</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ (s) nil)

(let* ((org-string "* Headline one    :foo:
* Headline two     :foo:bar:
* Headline three   :bar:")
       (result (__ org-string))
       (pass (equal result '(("Headline one" . ("foo"))
                          ("Headline two" . ("foo" "bar"))
                          ("Headline three" . ("bar"))))))
       (format "Pass:%S\n%S" pass result))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgea03bbf" class="outline-3">
<h3 id="orgea03bbf">Apply a custom font face to TODO words in a buffer</h3>
<div class="outline-text-3" id="text-orgea03bbf">
<p>
Each "TODO" word in the buffer below should have <code>my-todo-face</code> applied. You might
find it easier to open a test buffer where you can visually check the faces.
</p>

<p>
When you're done, try adjusting the exercise to support and test multiple faces,
or extend the face to apply to the rest of the line matching TODO.
</p>

<p>
The <a href="https://www.emacswiki.org/emacs/fic-mode.el">fic-mode codebase</a> may help you: it's a minor-mode that essentially just
highlights some user-defined keywords.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defface emacs-london/my-todo-face '((t (:inherit 'warning))) "")

(defun emacs-london/check-faces (buffer)
  "This returns a list where each item is t if the TODO font matches my-todo-face, else nil"
  (with-current-buffer buffer
    (save-excursion
      (goto-char (point-min))
      (cl-loop until (not (search-forward-regexp "TODO" nil t))
               collect (equal (face-at-point t) 'emacs-london/my-todo-face)))))

(defun __ (buffer))

(with-temp-buffer
  (insert "import math  # TODO: remove unused import

def main(arg):
    helloworld = 'helloworld'  # TODO: inline this?
    return helloworld

# TODO: execute main()?")

  (let* ((result (progn (__ (current-buffer))
                        (emacs-london/check-faces (current-buffer))))
         (pass (equal result '(t t t) )))
    (format "Pass:%S\n%S" pass result)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6725689" class="outline-3">
<h3 id="org6725689">Anagram finder</h3>
<div class="outline-text-3" id="text-org6725689">
<p>
Write a function which finds all the anagrams in a given vector of words. Your
function should return a list of lists, where each sub-list is a group of words
which are anagrams of each other. Words without any anagrams should not be
included in the result.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ (v) nil)

(let* ((result (__ ["meat" "mat" "team" "mate" "eat"]))
       (pass (equal result '(("meat" "team" "mate"))))
       (result2 (__ ["veer" "lake" "item" "kale" "mite" "ever"]))
       (pass2 (equal result '(("veer" "ever") ("lake" "kale") ("mite item")))))

  (format "Pass:%S\n%S\n\nPass:%S\n%S" pass result pass2 result2))
</pre>
</div>

<p>
(Ported from <a href="http://www.4clojure.com/problem/77">4Clojure #77</a>).
</p>
</div>
</div>

<div id="outline-container-org22ac9e1" class="outline-3">
<h3 id="org22ac9e1">Analyse a tic tac toe board</h3>
<div class="outline-text-3" id="text-org22ac9e1">
<p>
A tic-tac-toe board is represented by a two dimensional vector. X is represented
by <code>'x</code>, O is represented by <code>'o</code>, and empty is represented by <code>'e</code>. A player wins by
placing three Xs or three Os in a horizontal, vertical, or diagonal row. Write a
function which analyses a tic-tac-toe board and returns <code>'x</code> if X has won, <code>'o</code> if O
has won, and <code>nil</code> if neither player has won.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ (board) nil)

(let* ((result1 (__ [[e e e]
                     [e e e]
                     [e e e]]))
       (pass1 (equal nil result1))
       (result2 (__ [[x e o]
                     [x e e]
                     [x e o]]))
       (pass2 (equal 'x result2))
       (result3 (__ [[e x e]
                     [o o o]
                     [x e x]]))
       (pass3 (equal 'o result3))
       (result4 (__ [[x e o]
                     [x x e]
                     [o x o]]))
       (pass4 (equal nil result4))
       (result5 (__ [[x e o]
                     [o o e]
                     [o e x]]))
       (pass5 (equal 'o result5)))
  (format "Pass:%S\n%S\nPass:%S\n%S\nPass:%S\n%S\nPass:%S\n%S\nPass:%S\n%S\n"
          pass1 result1 pass2 result2 pass3 result3 pass4 result4 pass5 result5))
</pre>
</div>

<p>
(Ported from <a href="http://www.4clojure.com/problem/73">http://www.4clojure.com/problem/73</a>).
</p>
</div>
</div>

<div id="outline-container-org5f10b01" class="outline-3">
<h3 id="org5f10b01">Advice: 2 + 2 = 5</h3>
<div class="outline-text-3" id="text-org5f10b01">
<p>
The advice feature allows you to decorate other functions. This means you can
patch existing code to change its behaviour.
</p>

<p>
The first time your function is called, it should advise the <code>+</code> function so that
<code>(+ 2 2)</code> returns 5. The second time it's called, it should remove the advise, so
that subsequent calls to <code>+</code> return 4 again.
</p>

<p>
<b>Be careful with this. Breaking <code>(+)</code> could have unintended consequences!</b>
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun __ () nil)

(let* ((result1 (+ 2 2))
       (pass1 (equal result1 4))
       (result2 (progn (__) (+ 2 2)))
       (pass2 (equal result2 5))
       (result3 (progn (__) (+ 2 2)))
       (pass3 (equal result3 4)))
  (format "Pass:%S\n%S\n\nPass:%S:\n%S\n\nPass:%S\n%S"
          pass1 result1 pass2 result2 pass3 result3))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf59b3c8" class="outline-2">
<h2 id="orgf59b3c8">Open-ended project ideas</h2>
<div class="outline-text-2" id="text-orgf59b3c8">
<p>
Some ideas to get the conversation started:
</p>

<ul class="org-ul">
<li>Write a syntax highlighter for a language of your choice.</li>
<li>Build a fuzzy browser search interface to replace Spotlight/Alfred. You can
use <a href="http://xenodium.com/emacs-utilities-for-your-os/">Alvaro's excellent post</a> as a starting point.</li>
<li>Write a test runner that can run tests and display their output.</li>
<li>Write your own modeline.</li>
</ul>

<p>
See the <a href="projects.html">projects page</a> for more ideas.
</p>
</div>
</div>
</div>
</body>
</html>
